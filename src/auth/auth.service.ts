import { BadRequestException, ForbiddenException, Injectable, InternalServerErrorException, NotFoundException, UnauthorizedException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { User } from 'src/schemas/user.schema';
import { AuthDto } from './dto/auth.dto';
import { Sid } from 'src/schemas/sid.schema';
import { customAlphabet } from 'nanoid';
import * as dotenv from 'dotenv';
import { SbidUser } from './types/sbidUser';
import { schemaHas } from 'src/services/schemaHas';
dotenv.config();

@Injectable()
export class AuthService {
    constructor(
        @InjectModel(User.name) private readonly userModel:Model<User>,
        @InjectModel(Sid.name) private readonly sidModel: Model<Sid>
        ){}

    async auth(body: AuthDto){
        const {login, password} = body;
        const user = await this.userModel.findOne({login})
        if (!user) throw new NotFoundException();
        const isPassword = password === user.password;
        if(!isPassword) throw new UnauthorizedException()
        return "logged in"
    }

    /**
     * The function `sberBusinessIdAuth` is an asynchronous function that handles the authentication
     * process for SberBusiness ID.
     * @param {string} code - The `code` parameter is a string that represents the authorization code
     * received from the SberBusinessId authentication flow. This code is used to obtain an access
     * token and other necessary tokens for further authentication and authorization.
     * @param {string} state - The `state` parameter is a unique identifier that is generated by the
     * server and passed to the client as part of the authorization process. It is used to prevent
     * cross-site request forgery (CSRF) attacks.
     * If user doesn't exist it creates new User document with corresponding 
     * parameters from SberBusiness API
     */
    async sberBusinessIdAuth(code:string, state: string){
        console.log('code', code);
        console.log('state', state);
        const isState = await this.sidModel.findOne({sid:state});
        if(!isState) {
            throw new ForbiddenException();
        }
        console.log(process.env.SB_ID_TOKEN_URL);
        try {
            const response: any = await fetch(process.env.SB_ID_TOKEN_URL, {
                headers: {
                    'Content-type': 'application/x-www-form-urlencoded',
                    'Accept': 'application/jose',
                    'Access-Control-Allow-Origin': '*'
                },
                body: new URLSearchParams({
                    'grant_type': 'authorization_code',
                    'code': code,
                    'client_id': process.env.SB_ID_AUTH_CLIENT_ID,
                    'redirect_uri': process.env.SB_ID_AUTH_REDIRECT_URI,
                    'client_secret': process.env.SB_ID_CLIENT_SECRET 
                }),
                method: 'post',
                cache: 'no-cache'
            })
            if (response.status !== 200) throw new UnauthorizedException();
        const {
            access_token, 
            token_type, 
            refresh_token,
            id_token,
        } = response
        let token: string = '';
        await fetch(process.env.SB_ID_AUTH_USER_INFO_URL, {
            headers: {
                'Authorization': `${token_type} ${access_token}`
            },
        }).then(data => data.json()).then(data => token = data)
        if(!token) throw new BadRequestException();
        const [, payload] = token.split('.');
        const sbidUser: SbidUser = JSON.parse(Buffer.from(payload, 'base64').toString());
        if (!sbidUser.sub) return new BadRequestException();
        const user = await this.userModel.findOne({sub: sbidUser.sub});
        if(!user){
            const newUser = new this.userModel({
                refreshToken: refresh_token,
                idToken: id_token,
            })
            for(const key in sbidUser){
                if(schemaHas(newUser, key)) newUser[key] = sbidUser[key]
            }
            await newUser.save();
        } else {
            user.updateOne({refreshToken: refresh_token, idToken: id_token});
        }
        } catch (error) {
            console.log(error)
            throw new InternalServerErrorException()
        }
        
    }

    async refreshToken(){
        return 'here will be implementation of token routing'
    }


    /**
     * The function "getsids" retrieves all Session Ids
     */
    async getsids(){
        return await this.sidModel.find();
    }
    async deletesids(){
        const sids =  await this.sidModel.find();
        sids.forEach(async sid => {
            await sid.deleteOne();
        })
    }

    /**
     * The function generates authentication request parameters for a SberBusiness ID.
     * It creates new Session id (sid) document, that expires in 120 sec for
     * storing "state" and "nonce" unique values of unathorized user 
     * @returns a URL string that includes the following parameters:
     */
    async getAuthRequestParams(){
        const nid = customAlphabet('1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ', 36);
        const sid = new this.sidModel({nonce: nid(), sid:nid()});
        await sid.save();
        const scope = process.env.SB_ID_AUTH_SCOPE.split(' ').join('%20');
        const response_type = 'code';
        const state = sid.sid;
        const nonce = sid.nonce;
        const redirect_uri = process.env.SB_ID_AUTH_REDIRECT_URI.replaceAll(':', '%3A').replaceAll('/', '%3F');
        
        if(!scope || !state || !nonce || !redirect_uri) throw new BadRequestException();
         
        return `${process.env.SB_ID_AUTH_URL}?scope=${scope}&response_type=${response_type}&client_id=${process.env.SB_ID_AUTH_CLIENT_ID}&state=${state}&nonce=${nonce}&redirect_uri=${redirect_uri}`
    }
}
